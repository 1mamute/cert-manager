---
title: Server Side Apply
authors:
  - "@joshvanl"
reviewers:
  - @jetstack/team-cert-manager
approvers:
  - @jetstack/team-cert-manager
editor: "@joshvanl"
creation-date: 2022-01-18
last-updated: 2022-01-18
status: implementable
---

# Server Side Apply

## Table of Contents

<!-- toc -->
- [Summary](#summary)
  * [Conflicts](#conflicts)
  * [Deleting Fields](#deleting-fields)
- [Field Manager and User Agent](#field-manager-and-user-agent)
  * [Scheme](#scheme)
  * [Field Manager](#field-manager)
  * [User Agent](#user-agent)
- [Implementation Consideration](#implementation-consideration)
- [Feature Gate](#feature-gate)
<!-- /toc -->

## Summary

Server Side Apply is a [Kubernetes
feature](https://kubernetes.io/docs/reference/using-api/server-side-apply/)
whereby clients writing to a resource that is managed by more than one client
can

- declare what fields that client manages, and
- make decisions on what to do if there is a conflict with another client on
  what a field value should be.

Server Side Apply works by the client sending a PATCH API request with a
`Content-Type` header with the value `application/apply-patch+yaml`. The
`fieldManager=<my-field-manager>` URL query can be optionally sent which
instructs which field manager to use (or alternatively, will be derived from the
client's user agent). This API call tells the API server that the client wishes
to manage and set the fields and values of the resource (or alternatively remove
managed fields which are omitted) as the appear in the body, that have the field
manager name `<my-field-manager>` (or user agent equivalent).

Server Side Apply is is useful for cert-manager for 2 reasons:

### Conflicts

cert-manager controllers, namely the certificates controllers, where multiple
controllers are writing to the same resource type, lead to cases where UPDATE
operations result in resource version conflicts. This results in error logs
that regularly confuse users and miss-attribute the problem they are having, as
well as needless re-queuing churn through the controller slowing cert-manager
down.

### Deleting Fields

Without Server Side Apply, it is difficult for cert-manager to reason about some
fields that should be _deleted_ on an UPDATE operation during reconciliation.
One such example are Certificate SecretTemplate's Annotations and Labels. If a
key was removed from either field on the Certificate, the next reconciliation
would not know which keys should be preserved or removed (as they may have been
annotated or labelled from a third party).

Managed fields define ownership of these fields, therefore cert-manager is able
to observe a discrepancy due to a previous Certificate state and perform another
apply (omitting those keys), resulting in those fields being removed. Without
managed fields, cert-manager would have to create a third state store in either
annotations or status fields on that resource.


## Field Manager and User Agent

Field Manager is a string denoting the manager who owns a field or set of fields
on a resource. This string is set by the client at API call time and is
derived by either the client setting the `fieldManager` URL query explicitly, or
calculated from the client's user agent ([characters preceding the first /, quote
unprintable character and then trim what's beyond the 128
limit](https://github.com/kubernetes/kubernetes/blob/9a75e7b0fd1b567f774a3373be640e19b33e7ef1/staging/src/k8s.io/apiserver/pkg/endpoints/handlers/create.go#L252)).

cert-manager will use a consistent naming scheme for both the user agent prefix
and field manager across all components. Each component will have a human
readable name that describes that component, and is used for both its user agent
and field manager. Using the same name enables better auditing trails that helps
debugging and improves telemetry.

### Scheme

### Field Manager

The field manager is derived from the component in cert-manager, prefixed by the
string `cert-manager`:

```text
cert-manager-<cert-manager component>
```

e.g.

```text
cert-manager-certificates-issuing
```

### User Agent

The user agent is inspired by the [client-go default user
agent](https://github.com/kubernetes/client-go/blob/664b1a6c8ce9c92ce65bef3f9833b402449c98d2/rest/config.go#L499),
and is defined with the following:

```text
<component field manager>/<cert-manager version> (<Operating System>/<Architecture>) cert-manager/<git commit>
```

e.g:

```text
cert-manager-certificates-issuing/v1.7.0 (Linux/amd64) cert-manager/0b686b8f38c8c7442744c9224d18e780ee7f244a
```

## Implementation Consideration

All CREATE and UPDATE operations in cert-manager controllers are to be replaced
with APPLY. For this change, controllers will need to be modified so that for
these call, _only_ the fields in which they manage should be included in the
PATCH API call. This means each controller will need to define exactly which
fields they are concerned with.

Some fields, such as the Certificate Issuing Condition are managed by more than
one controller (issuing and trigger Certificate controllers), and as such, will
need to make use of the `force` option in their API calls. This option tells the
API server to revoke managment of that field from the previous owner, overwrite
the field, and change owner ship to the new client.

The [fake client-go client](https://github.com/kubernetes/client-go/issues/970)
does not support the Apply patch call for mocking API calls and events. This
means that significant controller unit-testing will either need to moved to
testing against a real API server as integration tests, the controller
[test framework must add custom support for Apply](https://github.com/jetstack/cert-manager/blob/master/pkg/controller/test/context_builder.go),
or a new testing framework should be developed.

## Feature Gate

Placing the APPLY functionality behind a feature gate should be considered.
Placing this functionality behind a feature gate would allow the cert-manager
authors gain confidence about its correctness, and ensure there are no
regressions in the stability of controller reconciliation.

To reach graduation, the cert-manager authors should consider the server side
apply implementation for cert-manager to be safe for end users. Graduation
should ideally be done over no more than a release or 2.
